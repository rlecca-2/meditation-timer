<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meditazione Quotidiana</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-amber-900 via-orange-900 to-red-900 flex items-center justify-center min-h-screen p-4">
  <div id="root" class="w-full max-w-2xl"></div>

  <!-- React + ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Componente MeditationTimer -->
  <script type="text/babel">

    const { useState, useEffect, useRef } = React;
    const { Play, Pause, SkipForward, Settings, Upload, Bell } = window; // lucide-react non funziona in standalone, useremo emoji o SVG alternativi

    const MeditationTimer = () => {
      const defaultPhases = [
        { id: 0, name: 'Campana iniziale', duration: 3, type: 'bell' },
        { id: 1, name: 'Consapevolezza del respiro', duration: 120, type: 'silence' },
        { id: 2, name: 'Presa di rifugio', duration: 60, type: 'silence' },
        { id: 3, name: 'Motivazione', duration: 60, type: 'silence' },
        { id: 4, name: 'Ascolto audio MP3', duration: 450, type: 'audio' },
        { id: 5, name: 'Meditazione in silenzio', duration: 300, type: 'silence' },
        { id: 6, name: 'Campane finali', duration: 5, type: 'threeBells' }
      ];

      const [phases, setPhases] = useState(defaultPhases);
      const [currentPhaseIndex, setCurrentPhaseIndex] = useState(-1);
      const [timeLeft, setTimeLeft] = useState(0);
      const [isRunning, setIsRunning] = useState(false);
      const [showSettings, setShowSettings] = useState(false);
      const [audioFile, setAudioFile] = useState(null);
      const [audioUrl, setAudioUrl] = useState(null);

      const audioRef = useRef(null);
      const audioContextRef = useRef(null);

      const generateBellSound = () => {
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = audioContextRef.current;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = 528;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 2);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 2);
      };

      const handleAudioUpload = (e) => {
        const file = e.target.files?.[0];
        if (file) {
          const isAudio = file.type.startsWith('audio/') || file.name.match(/\.(mp3|ogg|wav|m4a|opus)$/i);
          if (isAudio) {
            setAudioFile(file);
            setAudioUrl(URL.createObjectURL(file));
          } else {
            alert('Carica un file audio valido');
          }
        }
      };

      const startMeditation = () => {
        if (currentPhaseIndex === -1) {
          setCurrentPhaseIndex(0);
          setTimeLeft(phases[0].duration);
        }
        setIsRunning(true);
      };

      const togglePause = () => {
        setIsRunning(!isRunning);
        if (audioRef.current && phases[currentPhaseIndex]?.type === 'audio') {
          if (isRunning) audioRef.current.pause();
          else audioRef.current.play();
        }
      };

      const skipPhase = () => {
        if (currentPhaseIndex < phases.length - 1) {
          if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0;
          }
          const nextIndex = currentPhaseIndex + 1;
          setCurrentPhaseIndex(nextIndex);
          setTimeLeft(phases[nextIndex].duration);
        }
      };

      const resetMeditation = () => {
        setIsRunning(false);
        setCurrentPhaseIndex(-1);
        setTimeLeft(0);
        if (audioRef.current) {
          audioRef.current.pause();
          audioRef.current.currentTime = 0;
        }
      };

      useEffect(() => {
        if (!isRunning || currentPhaseIndex === -1) return;
        const currentPhase = phases[currentPhaseIndex];
        if (timeLeft === currentPhase.duration) {
          if (currentPhase.type === 'bell') generateBellSound();
          else if (currentPhase.type === 'threeBells') {
            generateBellSound();
            setTimeout(() => generateBellSound(), 1000);
            setTimeout(() => generateBellSound(), 2000);
          } else if (currentPhase.type === 'audio' && audioRef.current && audioUrl) {
            audioRef.current.play();
          }
        }

        const interval = setInterval(() => {
          setTimeLeft(prev => {
            if (prev <= 1) {
              if (currentPhaseIndex < phases.length - 1) {
                const nextIndex = currentPhaseIndex + 1;
                setCurrentPhaseIndex(nextIndex);
                return phases[nextIndex].duration;
              } else {
                setIsRunning(false);
                return 0;
              }
            }
            return prev - 1;
          });
        }, 1000);

        return () => clearInterval(interval);
      }, [isRunning, currentPhaseIndex, timeLeft, phases, audioUrl]);

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2,'0')}`;
      };

      return (
        <div className="bg-white/10 backdrop-blur-lg rounded-3xl shadow-2xl p-8 max-w-2xl w-full border border-amber-700/30 text-amber-50">
          <h1 className="text-4xl font-bold text-center mb-8 flex items-center justify-center gap-3">
            üîî Meditazione Quotidiana
          </h1>

          {!audioFile && currentPhaseIndex === -1 && (
            <div className="mb-8 bg-amber-950/30 rounded-xl p-6 border-2 border-dashed border-yellow-700/50">
              <label className="flex flex-col items-center cursor-pointer">
                üì§
                <span className="text-lg mb-2">Carica l'audio di oggi</span>
                <input type="file" accept="audio/*,.ogg,.opus" onChange={handleAudioUpload} className="hidden" />
              </label>
            </div>
          )}

          {audioFile && (
            <div className="mb-6 bg-yellow-700/30 rounded-lg p-4 text-amber-50 border border-yellow-700/50">
              ‚úì Audio caricato: {audioFile.name}
            </div>
          )}

          {currentPhaseIndex >= 0 && (
            <div className="text-center mb-8">
              <div className="text-6xl font-bold mb-4">{formatTime(timeLeft)}</div>
              <div className="text-2xl mb-2">{phases[currentPhaseIndex]?.name}</div>
              <div className="text-amber-200/70">
                Fase {currentPhaseIndex + 1} di {phases.length}
              </div>
              <div className="w-full bg-amber-950/40 rounded-full h-2 mt-4">
                <div
                  className="bg-yellow-600 h-2 rounded-full transition-all duration-1000"
                  style={{ width: `${((phases[currentPhaseIndex].duration - timeLeft)/phases[currentPhaseIndex].duration)*100}%` }}
                />
              </div>
            </div>
          )}

          <div className="flex justify-center gap-4 mb-6">
            {currentPhaseIndex === -1 ? (
              <button onClick={startMeditation} disabled={!audioFile} className="bg-yellow-700 hover:bg-yellow-600 disabled:bg-gray-600 rounded-full p-6">
                ‚ñ∂Ô∏è
              </button>
            ) : (
              <>
                <button onClick={togglePause} className="bg-yellow-700 hover:bg-yellow-600 rounded-full p-6">
                  {isRunning ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
                </button>
                <button onClick={skipPhase} disabled={currentPhaseIndex >= phases.length - 1} className="bg-orange-800 hover:bg-orange-700 disabled:bg-gray-600 rounded-full p-6">
                  ‚è≠Ô∏è
                </button>
              </>
            )}
            <button onClick={() => setShowSettings(!showSettings)} className="bg-red-900 hover:bg-red-800 rounded-full p-6">
              ‚öôÔ∏è
            </button>
          </div>

          {currentPhaseIndex >= 0 && (
            <button onClick={resetMeditation} className="w-full bg-red-900/40 hover:bg-red-900/60 text-amber-100 py-3 rounded-lg transition-all border border-red-800/50">
              Ricomincia da capo
            </button>
          )}

          {showSettings && currentPhaseIndex === -1 && (
            <div className="mt-6 bg-amber-950/30 rounded-xl p-6 border border-yellow-800/30">
              <h3 className="text-xl font-semibold mb-4">Configura le fasi</h3>
              <div className="space-y-3">
                {phases.map(phase => (
                  <div key={phase.id} className="flex items-center justify-between bg-amber-900/30 p-3 rounded-lg border border-yellow-800/20">
                    <span className="flex-1">{phase.name}</span>
                    <div className="flex items-center gap-2">
                      <input
                        type="number"
                        value={Math.floor(phase.duration/60)}
                        onChange={(e)=>setPhases(phases.map(p=>p.id===phase.id?{...p,duration:parseInt(e.target.value)*60}:p))}
                        className="w-16 bg-amber-950/50 text-amber-50 rounded px-2 py-1 text-center border border-yellow-800/30"
                        min="0"
                      />
                      <span className="text-amber-200 text-sm">min</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          <audio ref={audioRef} src={audioUrl||''} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<MeditationTimer />);

  </script>
</body>
</html>
